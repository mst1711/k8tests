# Ответы на тестовые задачи

1. https://github.com/mst1711/k8tests/tree/main/issue1

2. Самый простой вариант при условии, что все хосты имеют одинаковые fqdn имена, различающиеся только порядковым индексом:
```
for i in $(seq 1 120); do \
    scp -i ~/.ssh/key /path/to/new/config/nginx.conf root@our-host-$i.our-domain.com:/etc/nginx/nginx.conf; \
    ssh -i ~/.ssh/key root@our-host-$i.our-domain.com nginx -s reload; \
done
```
В более сложном случае можно написать bash скрипт с проверками на корректность конфигруационного файла на конкретном хосте либо написать ansible playbook с доставкой нового конфига и перезапуском nginx

3. Воспользуемся fail2ban
/etc/fail2ban/filter.d/nginx-errors.conf
```
[Definition]
failregex = <HOST> .* 410 .*
            <HOST> .* 403 .*
ignoreregex =
```
/etc/fail2ban/jail.d/nginx-errors.conf
```
[nginx-errors]
enabled = true
filter = nginx-errors
logpath = /var/log/nginx/access.log
maxretry = 60
bantime = 2700
findtime = 180
action = iptables-multiport[name=nginx, port="80,443", protocol=tcp]
```

4. Предварительно условимся, что mount point прописан в fstab
- Локально создаем файл со следующим содержимым
**check_mount.sh**
```
#!/bin/bash

CHECK_PATH="/opt/data"
mount | grep $CHECK_PATH 2>&1 > /dev/null
if [ $(echo $?) == "0" ]; then
    exit 0
fi

res=1
until [ $res == "0" ]; do
    mount $CHECK_PATH 2>&1 > /dev/null
    res=$(echo $?)
done

```
- а потом запускаем его на всех 120 машинах
```
for i in $(seq 1 120); do cat check_mount.sh | ssh -i ~/.ssh/key root@our-host-$i.our-domain.com bash; done
```

5. 
- Блокировка другой транзакцией. Эта ошибка может возникнуть, когда транзакция на slave-сервере ожидает блокировки, удерживаемой другой транзакцией, выполняющейся на master-сервере. Если блокировка не снимается в течение заданного времени (timeout), возникает данная ошибка. Возможные причины включают длительные операции записи на master-сервере или длительные транзакции, блокирующие доступ к записи.
- Синхронизация binlog-файлов: Если slave-сервер не успевает обработать binlog-файлы, передаваемые с master-сервера, может возникнуть блокировка и превышение времени ожидания.
- Неправильная конфигурация или недостаточные ресурсы: Если slave-сервер имеет недостаточно ресурсов (например, CPU, память, дисковое пространство), он может не успевать обрабатывать репликацию в реальном времени. Также, неправильная конфигурация параметров репликации, таких как innodb_lock_wait_timeout или slave_net_timeout, может привести к превышению времени ожидания.

6. 
```
# apt install sfdisk

# swapoff -a

# sfdisk -d /dev/sda | sfdisk /dev/sdd
# sync

# mdadm /dev/md0 --remove /dev/sdd1
# mdadm /dev/md1 --remove /dev/sdd2
# mdadm /dev/md2 --remove /dev/sdd3

# mdadm /dev/md0 -a /dev/sdd1
# mdadm /dev/md1 -a /dev/sdd2
# mdadm /dev/md2 -a /dev/sdd3

# mkfs.xfs /dev/sdd4
# blkid | grep sdd4
# vi /etc/fstab (правим UUID на новый, если монтирование было по UUID либо пропускаем этот шаг)
# mount /mnt/sdd4

# mkswap /dev/md2
# swapon
```

7. Доступны два варианта:
```
rsync -e "ssh -i ~/.ssh/key" -avz --progress root@serverA@/path/to/source/directory root@serverB:/path/to/destination/directory
```
и второй с использованием ssh агента
предварительно он должен быть установлен, запущен и добавлен ключ
```
ssh -A root@serverA
scp -r /path/to/source/directory root@serverB:/path/to/destination/directory
```

8. Вероятно веб-приложение выполняет какие-то ресурсоемкие задачи в результате которых даже небольшое увеличение запросов приводит к нагрузке на сервер. Другой вариант - нагрузку на сервер создает не веб-приложение, а что-то другое и на работу веб-приложения остается мало ресурсов сервера.
Проверить не работает ли на сервере какое-то несанкционированное ПО.

9. 
```
    location /hls {
        limit_except GET {
            deny  all;
        }

        root /opt/video/;

        hls;
        hls_path /tmp;
        hls_fragment 5s;
        hls_playlist_length 30s;
        hls_continuous off;
        hls_limit_rate 8m;
        types {
            application/vnd.apple.mpegurl m3u8;
            video/mp2t ts;
            video/mp4 mp4;
        }
    }
```

10. 
- Запросы с большим потреблением ресурсов: возможно появились (или были) запросы, которые требуют большого объема ресурсов, таких как сложные JOIN-запросы, сортировка или группировка большого количества данных. Такие запросы могут занимать значительное время и потреблять много памяти и процессорного времени, что приводит к увеличению нагрузки. С увеличением базы такие запросы будут отъедать все больше и больше ресурсов.
В этом случае нужно подключить разработчиков к решению этой проблемы. Опитимизировать запросы.

- Недостаточная конфигурация сервера: нужно проверить настройки MySQL и убедиться, что они соответствуют требованиям приложения и объему данных. Увеличение значений параметров, таких как *innodb_buffer_pool_size*, *max_connections* и *query_cache_size*, может помочь улучшить производительность.

- Блокировки и конфликты: нередкая проблема блокировок и конфликтов в базе данных. Длинные блокировки или транзакции могут приводить к задержкам и увеличению нагрузки на сервер.

- Неправильные индексы: возможно не хватает индексов. Отсутствие или неправильное использование индексов может приводить к медленной работе запросов и увеличению нагрузки на сервер.

- Повышенный трафик или пользователи: возможно повысился трафик на основной ресурс и вслед за этим обращения к базе. В этом случае полезно также проверить нет ли аномального трафика (ddos и пр)

11. 
- Расписание задач: возможно, в это время на сервере запускаются какие-то задачи или процессы, которые занимают много ресурсов или влияют на доступность сервера. Причем не обязательно именно на этом сервере.
- Превышение ресурсов: утренний пик активности может приводить к превышению ресурсов сервера, таких как CPU, память или сетевой трафик.
